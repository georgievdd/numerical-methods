#include <iostream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <clocale>
#include <Windows.h>

// Определяем глобальные переменные, которые используются в различных функциях
float *M, *MM, eps, epst, t; // M и MM - это матрицы, eps - точность, epst - текущая точность, t - параметр релаксации
int n, iter, it; // n - размерность системы, iter - число итераций, it - счетчик итераций

// Прототипы функций
int iter_Up(); // Функция для выполнения итераций метода релаксации
void var_M(); // Функция для преобразования системы
void Ax_b(); // Функция для вычисления невязки (остатка)

// Макросы для удобного обращения к элементам матриц M и MM
#define A(i, j) M[(i) * (n + 2) + (j)] // Используется для работы с матрицей A
#define B(i, j) MM[(i) * (n + 2) + (j)] // Используется для работы с матрицей B

int main() {
    // Установка локализации и кодировки консоли для корректного отображения русских символов
    setlocale(LC_CTYPE, "");
    SetConsoleCP(CP_UTF8);
    SetConsoleOutputCP(CP_UTF8);

    // Объявление локальных переменных
    int i, j, code, fl = 0, c; 
    int fl1 = 0, iopt; // fl1 - флаг для контроля процесса, iopt - оптимальное количество итераций
    float topt, dt = 0.05; // topt - оптимальное значение параметра t, dt - шаг изменения t
    char s[2];

    // Вывод приветственного сообщения и ввод размерности системы
    std::wcout << " * Программа находит решение системы методом верхней релаксации * " << std::endl;
    std::wcout << "Введите размерность системы: ";
    std::wcin >> n;

    // Выделение памяти для матриц системы
    M = (float *)malloc(n * (n + 2) * sizeof(float)); // Матрица A
    MM = (float *)malloc(n * (n + 2) * sizeof(float)); // Матрица B

    // Ввод способа задания системы: случайно или вручную
    std::cout << "Введите 0/1 - задать систему случайным образом или вручную: ";
    std::cin >> c;

    // В зависимости от выбора пользователя, система задается либо случайными значениями, либо вводится вручную
    switch (c) {
        case 0: // Случайная генерация матрицы
            srand(time(NULL));
            for (i = 0; i < n; i++)
                for (j = 0; j < n + 1; j++)
                    B(i, j) = 0.5f - rand() / (RAND_MAX + 1.0f);
            break;
        default: // Ручной ввод матрицы
            for (i = 0; i < n; i++) {
                for (j = 0; j < n; j++) {
                    std::cout << "Введите B(" << i << "," << j << "): ";
                    std::cin >> B(i, j);
                }
                std::cout << "Введите b(" << i << "): ";
                std::cin >> B(i, n);
            }
    }

    // Вывод введенной системы
    std::cout << "Введенная система:" << std::endl;
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            std::cout << B(i, j) << " ";
        }
        std::cout << B(i, n) << std::endl;
    }

    // Преобразование системы для использования в методе релаксации
    var_M();

    // Вывод преобразованной системы
    std::cout << "Преобразованная система:" << std::endl;
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            std::cout << A(i, j) << " ";
        }
        std::cout << A(i, n) << std::endl;
    }

    // Основной цикл решения системы методом верхней релаксации
    while (fl == 0) {
        // Ввод параметров итерационного процесса
        std::cout << "Введите число итераций, точность и параметр t: ";
        std::cin >> iter >> eps >> t;

        var_M(); // Повторное преобразование системы с новыми параметрами
        code = iter_Up(); // Выполнение итерационного процесса

        // Обработка результата итерационного процесса
        switch (code) {
            case 0: // Решение найдено
                std::cout << "\nКод = " << code << ", Число использованных итераций = " << it << ", Точность = " << epst << std::endl;
                std::cout << "Решение:" << std::endl;
                for (i = 0; i < n; i++) {
                    std::cout << A(i, n + 1) << " ";
                }

                Ax_b(); // Вычисление невязки (разница между результатом и правой частью уравнения)
                std::cout << "\nНевязка:" << std::endl;
                for (i = 0; i < n; i++) {
                    std::cout << B(i, n + 1) << " ";
                }

                // Предложение найти оптимальный параметр t
                std::cout << "\nНайти оптимальное t -> Введите 0, иначе 1 - ввод новых параметров, 2 - выход: ";
                std::cin >> fl1;

                if (fl1 == 1 || fl1 == 2) break; // Завершение программы или ввод новых параметров

                if (fl1 == 0) {
                    iopt = iter; // Начальное значение для числа итераций
                    t = 0; // Начальное значение для t

                    // Поиск оптимального значения параметра t
                    for (i = 0; i < 40; i++) {
                        t += dt; // Увеличение t на шаг dt
                        var_M(); // Преобразование системы
                        code = iter_Up(); // Выполнение итерационного процесса

                        // Обновление оптимальных значений t и числа итераций
                        if ((code == 0) && (it < iopt)) {
                            iopt = it;
                            topt = t;
                        }
                    }

                    // Вывод найденных оптимальных значений
                    std::cout << "\nПолучены следующие оптимальные значения t и iter: " << topt << "; " << iopt << std::endl;
                    std::cout << "\nПовторить вычисления для новых параметров итерационного процесса - введите 0, иначе 1: ";
                    std::cin >> fl; // Пользователь может повторить расчет с новыми параметрами
                }
                break;
            case 1: // Обнаружен нулевой элемент на диагонали матрицы
                std::cout << "\nВ матрице системы есть диагональный компонент = 0!" << std::endl;
                fl = 1;
                break;
            case 2: // Метод разошелся (не сходится)
                std::cout << "\nМетод разошелся!" << std::endl;
                break;
        }
    }

    // Завершение программы
    std::cout << "\nДля завершения программы нажмите любую клавишу и ENTER ";
    std::cin >> s;
    std::cout << std::endl;

    // Освобождение выделенной памяти
    free(M);
    free(MM);
    return 0;
}

// Функция для выполнения итерационного процесса метода верхней релаксации
int iter_Up() {
    int i, j, k, fl = 0;
    float nt, buf, norm, norm_old = 0, t1 = 1 - t; // t1 - вспомогательная переменная для вычислений
    for (i = 0; i < n; i++) {
        A(i, n + 1) = A(i, n); // Запоминаем правую часть уравнений
        if (fabs(A(i, i)) < 1.E-30) return 1; // Проверка на нулевые элементы на диагонали
        A(i, n) = t * A(i, n) / A(i, i); // Нормализация правой части

        for (j = 0; j < n; j++) {
            if (i != j) A(i, j) = t * A(i, j) / A(i, i); // Нормализация коэффициентов матрицы
        }
    }

    it = 0; // Сброс счетчика итераций

    for (k = 1; k <= iter; k++) {
        it++;
        norm = 0; // Сброс нормы

        for (i = 0; i < n; i++) {
            buf = t1 * A(i, n + 1) + A(i, n); // Вычисление новой итерации для решения
            for (j = 0; j < n; j++) {
                if (i != j) buf -= A(i, j) * A(j, n + 1); // Итерационная поправка
            }
            nt = fabs(buf - A(i, n + 1)); // Оценка точности
            A(i, n + 1) = buf; // Обновление решения

            if (nt > norm) norm = nt; // Обновление нормы
        }

        epst = norm; // Сохранение текущей нормы
        if (norm <= eps) return 0; // Если точность достигнута, метод завершен
        if (norm > norm_old) fl++; // Если точность ухудшается, увеличиваем счетчик ошибок
        else fl = 0; // Если норма уменьшается, сбрасываем счетчик ошибок
        if (fl > 3) return 2; // Если подряд было несколько ошибок, метод не сходится
        norm_old = norm; // Запоминаем старую норму
    }

    return 0; // Если итерации завершены, возвращаем 0
}

// Преобразование матрицы системы для метода релаксации
void var_M() {
    int i, j, k;

    for (i = 0; i < n; i++) {
        for (j = 0; j <= n; j++) {
            A(i, j) = 0.0f;
            for (k = 0; k < n; k++) {
                A(i, j) += B(k, i) * B(k, j); // Преобразование матрицы
            }
        }
    }
}

// Вычисление невязки (остатка)
void Ax_b() {
    int i, j;
    for (i = 0; i < n; i++) {
        B(i, n + 1) = B(i, n); // Запоминаем правую часть
        for (j = 0; j < n; j++) {
            B(i, n + 1) -= B(i, j) * A(j, n + 1); // Вычисляем невязку
        }
    }
}
